; Copyright (c) 2020, Antonie Blom
;
; Permission to use, copy, modify, and/or distribute this software for any
; purpose with or without fee is hereby granted, provided that the above
; copyright notice and this permission notice appear in all copies.
;
; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
; WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
; MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
; ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
; ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
; OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

(def defmacro (macro (: name args body) `(def ,name (macro ,args ,@body))))
(defmacro defun      (: name args body) `(def ,name (fn    ,args ,@body)))

(defun bool-err () (throw ETYPE "expected boolean"))

(defmacro if   (c t e) `(case ,c (true    ,t) (false   ,e) (_ (bool-err))))
(defmacro when   (c t) `(case ,c (true    ,t) (false   ()) (_ (bool-err))))
(defmacro unless (c t) `(case ,c (false   ,t) (true    ()) (_ (bool-err))))
(defun    not      (x)  (case  x (false true) (true false) (_ (bool-err))))
(defmacro and    (a b) `(if ,a   ,b false))
(defmacro or     (a b) `(if ,a true    ,b))

(defmacro do body `(let () ,@body))

(defun any-of? (ty-in types)
  (case types
    ((: ty tys) (or (= ty-in ty) (any-of? ty-in tys)))
    (()         false)))
(defmacro type-assert (: symbol types)
 `(unless (any-of? (type-of ,symbol) (list ,@types))
    (throw ETYPE (format "`{}' must have type {}" ',symbol (join ',types " or ")))))

(def nil ())

(def Nil       (type-of nil))
(def ID        (type-of 'a))
(def Int       (type-of 0))
(def Double    (type-of 0.0))
(def Bool      (type-of true))
(def List      (type-of '(0)))
(def Func      (type-of (fn () ())))
(def Macro     (type-of (macro () ())))
(def ExtFunc   (type-of type-of))
(def Quote     (type-of ''0))
(def BackQuote (type-of '`0))
(def String    (type-of ""))
(def Env       (type-of ((fn () (env)))))

(defsym iota
  (var _iota 0)
  (defget (let ((res _iota)) (set _iota (+ res 1)) res))
  (defset
    (type-assert value Int)
    (set _iota value)))

(defun unsafe-map (f xs)
  (case xs
    (() ())
    ((: z zs) (: (f z) (unsafe-map f zs)))))
(defun map (f xs)
  (type-assert f Func ExtFunc)
  (type-assert xs List Nil)
  (unsafe-map f xs))

(defun head ((: x _)) x)
(defun tail ((: _ xs)) xs)
(defun last ((: x xs))
  (case xs
    (() x)
    (_  (last xs))))

(defun call (f args) (eval (: f args)))
(defun list args args)

(defun unsafe-filter (p xs)
  (case xs
    (() ())
    ((: z zs) (if (p z)
                (: z (unsafe-filter p zs))
                (unsafe-filter p zs)))))
(defun filter (p xs)
  (type-assert p Func ExtFunc)
  (type-assert xs List Nil)
  (unsafe-filter p xs))

(defun unsafe-any? (p xs)
  (case xs
    (() false)
    ((: y ys) (if (p y) true (unsafe-any? p ys)))))
(defun any? (p xs)
  (type-assert p Func ExtFunc)
  (type-assert xs List Nil)
  (unsafe-any? p xs))

(defun unsafe-all? (p xs)
  (case xs
    (() true)
    ((: y ys) (and (p y) (unsafe-all? p ys)))))
(defun all? (p xs)
  (type-assert p Func ExtFunc)
  (type-assert xs List Nil)
  (unsafe-all? p xs))

(defun unsafe-foldr (f start lst)
  (case lst
    (() start)
    ((: z zs) (f z (unsafe-foldr f start zs)))))
(defun foldr (f start lst)
  (type-assert f Func ExtFunc)
  (type-assert lst List Nil)
  (unsafe-foldr f start lst))

(defun unsafe-foldl (f start lst)
  (case lst
    (() start)
    ((: z zs) (unsafe-foldl f (f start z) zs))))
(defun foldl (f start lst)
  (type-assert f Func ExtFunc)
  (type-assert lst List Nil)
  (unsafe-foldl f start lst))

(defun element? (e xs)
  (any? (fn (x) (= e x)) xs))

(defun unsafe-strfind (e s)
  (if (prefix? e s)
    0
    (if (= s "")
      nil
      (case (unsafe-strfind e (substr s 1))
        (() nil)
        (n  (+ n 1))))))
(defun unsafe-find (e xs)
  (case xs
    ((: y ys)
      (if (= e y)
        0
        (case (unsafe-find e ys)
          (() nil)
          (n  (+ n 1)))))
    (() nil)))
(defun find (e xs)
  (if (= (type-of xs) String)
    (do (type-assert e String)
        (unsafe-strfind e xs))
    (do (type-assert xs List Nil)
        (unsafe-find e xs))))

(defun zip-with (: op args)
  (case args
    ((as ()) ())
    ((() bs) ())
    (((: a as) (: b bs)) (: (op a b) (zip-with op as bs)))))
(defun zip (xs ys)
  (zip-with list xs ys))

(defun ++helper (xs ys)
  (case xs
    ((: z zs) (: z (++helper zs ys)))
    (() ys)))
(defun ++ (xs ys)
  (if (= (type-of xs) String)
    (do (type-assert ys String)
        (format "{}{}" xs ys))
    (do (type-assert xs List Nil)
        (type-assert ys List Nil)
        (case ys
          (() xs)
          (_  (++helper xs ys))))))

(defun concat (xs) (foldr ++ () xs))
(defun strcat (xs) (foldr ++ "" xs))
(defun append args (concat args))

(defun rev-helper (xs ys)
  (case xs
    (() ys)
    ((: z zs) (rev-helper zs (: z ys)))))
(defun reverse (xs)
  (type-assert xs List Nil)
  (rev-helper xs ()))

(defun length (xs) (foldr (fn (_ l) (+ 1 l)) 0 xs))

(defun unsafe-!! (xs i orig-i)
  (case xs
    ((: y ys) (if (= i 0) y (unsafe-!! ys (- i 1) orig-i)))
    (() (throw EINDEX (format "index {} out of bounds" orig-i)))))
(defun !! (xs i)
  (type-assert xs List Nil)
  (type-assert i Int)
  (when (< i 0)
    (throw EINDEX (format "expected non-negative index (got {})" i)))
  (unsafe-!! xs i i))

(defun list-prefix? (pfx arg)
  (case pfx
    ((: p ps)
      (case arg
        ((: a as) (and (= p a) (list-prefix? ps as)))
        (()       false)))
    (() true)))
(defun prefix? (pfx arg)
  (if (= (type-of pfx) String)
    (do (type-assert arg String)
        (let ((n (string-length pfx)))
          (and (<= n (string-length arg)) (= pfx (substr arg 0 n)))))
    (do (type-assert pfx List Nil)
        (type-assert arg List Nil)
        (list-prefix? pfx arg))))

(defun suffix? (sfx arg)
  (if (= (type-of sfx) String)
    (do (type-assert arg String)
        (let ((n (string-length sfx)) (m (string-length arg)))
          (and (<= n m) (= sfx (substr arg (- m n))))))
    (do (type-assert sfx List Nil)
        (type-assert arg List Nil)
        (list-prefix? (reverse sfx) (reverse arg)))))

(defun show (arg) (format "{!s}" arg))
(defun repr (arg) (format "{!r}" arg))

(defun unsafe-split (s at)
  (case (find at s)
    (() s)
    (n  (: (substr s 0 n) (unsafe-split (substr s (+ n (string-length at))) at)))))
(defun split (s at)
  (type-assert s String)
  (type-assert at String)
  (unsafe-split s at))

(defun unsafe-join (xs j)
  (case xs
    ((y)      (show y))
    ((: y ys) (format "{}{}{}" y j (unsafe-join ys j)))
    (()       "")))
(defun join (xs j)
  (type-assert xs List Nil)
  (type-assert j String)
  (unsafe-join xs j))

(defun read () (read-from stdin))
(defun print (arg) (print-to stdout arg))
(defun put (arg) (put-to stdout arg))
(defun get-line () (get-line-from stdin))
(defun get-byte () (get-byte-from stdin))

(defun sum (args) (foldr + 0 args))
(defun product (args) (foldr * 1 args))

(defun ~ (x) (- 0 x))

(defun ..helper (from to step fin)
  (if (fin from to)
    ()
    (: from (..helper (+ from step) to step fin))))
(defun .. (from to)
  (type-assert from Int)
  (type-assert to Int)
  (if (<= from to)
    (..helper from to  1 >)
    (..helper from to -1 <)))

(defun maximum ((: x xs))
  (foldr (fn (a b) (if (> a b) a b)) x xs))
(defun minimum ((: x xs))
  (foldr (fn (a b) (if (< a b) a b)) x xs))

(defun max args (maximum args))
(defun min args (minimum args))

(defun clamp (x a b)
  (type-assert x Int Double)
  (type-assert a Int Double)
  (type-assert b Int Double)
  (if (< x a)
    a
    (if (> x b)
      b
      x)))
(defun lerp (a b t)
  (type-assert a Int Double)
  (type-assert b Int Double)
  (type-assert t Int Double)
  (+ a (* t (- b a))))
